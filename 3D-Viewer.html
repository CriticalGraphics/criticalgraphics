<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D OBJ Viewer (GitHub Raw)</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; }
    body {
      width: 100vw; height: 100vh;
      /* Fondo gradiente */
      background: radial-gradient(ellipse at center, #24243e 0%, #302b63 70%, #0f0c29 100%);
    }
    #container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; }
    #debug { position: fixed; left: 10px; bottom: 10px; color: #fff; background: rgba(0,0,0,0.7); padding: 10px 16px; border-radius: 8px; font-family: monospace; z-index: 10;}
  </style>
</head>
<body>
  <div id="container"></div>
  <div id="debug">Waiting for model...</div>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';
    import { OBJLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/OBJLoader.js';

    const OBJ_URL = "https://raw.githubusercontent.com/CriticalGraphics/criticalgraphics/main/models/modelo1.obj";
    let camera, scene, renderer, controls, model;
    const debugMsg = document.getElementById('debug');

    // Init scene
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.05, 1000);
    camera.position.set(0, 2, 5);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setClearColor(0x000000, 0); // Mantiene el gradiente del body
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('container').appendChild(renderer.domElement);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.1);
    dirLight.position.set(5, 10, 7);
    scene.add(dirLight);

    function setDebug(msg, ok) {
      debugMsg.textContent = msg;
      debugMsg.style.background = ok === undefined ? 'rgba(0,0,0,0.7)' : (ok ? 'rgba(0,80,0,0.7)' : 'rgba(80,0,0,0.7)');
      debugMsg.style.color = ok === undefined ? '#fff' : (ok ? '#b0ffb0' : '#ffb0b0');
    }

    function fitAndScaleModel(camera, object, scaleTo = 0.7) {
      const box = new THREE.Box3().setFromObject(object);
      if (!isFinite(box.min.x) || !isFinite(box.max.x)) return;
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());

      object.position.sub(center);

      const maxDim = Math.max(size.x, size.y, size.z);
      if (maxDim > 0) {
        const scale = scaleTo / maxDim;
        object.scale.set(scale, scale, scale);
      }
      const scaledBox = new THREE.Box3().setFromObject(object);
      const scaledSize = scaledBox.getSize(new THREE.Vector3());
      const scaledMaxDim = Math.max(scaledSize.x, scaledSize.y, scaledSize.z);
      const fov = camera.fov * (Math.PI / 180);
      let cameraZ = Math.abs(scaledMaxDim / 2 / Math.tan(fov / 2)) * 1.6;
      camera.position.set(0, 0, cameraZ);
      camera.lookAt(0, 0, 0);

      controls.target.set(0, 0, 0);
      controls.maxDistance = cameraZ * 10;
      controls.minDistance = cameraZ * 0.25;
      controls.update();
    }

    function loadOBJModel(objUrl) {
      setDebug('Loading model: ' + objUrl);
      const loader = new OBJLoader();
      loader.load(objUrl, (obj) => {
        if (model) scene.remove(model);
        model = obj;
        model.traverse(child => {
          if (child.isMesh) {
            child.material = new THREE.MeshStandardMaterial({
              color: 0xaaaaaa,
              metalness: 0.2,
              roughness: 0.75
            });
          }
        });
        scene.add(model);
        fitAndScaleModel(camera, model, 0.7);
        setDebug('Model loaded!', true);
      }, (xhr) => {
        if (xhr.lengthComputable) {
          setDebug(`Loading model: ${(xhr.loaded / xhr.total * 100).toFixed(1)}%`);
        }
      }, (err) => {
        setDebug('Could not load model: ' + objUrl, false);
      });
    }

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // Load model from GitHub Raw
    loadOBJModel(OBJ_URL);
  </script>
</body>
</html>
